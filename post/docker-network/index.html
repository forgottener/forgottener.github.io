<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Docker Network介绍 - 猿资猿味 - 高波的博客</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="forgottener"><meta name=description content="Docker 网络介绍"><meta name=keywords content="docker,network">
<meta name=generator content="Hugo 0.87.0 with theme even">
<link rel=canonical href=https://gaoboy.com/post/docker-network/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link href=/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content="Docker Network介绍">
<meta property="og:description" content="Docker 网络介绍">
<meta property="og:type" content="article">
<meta property="og:url" content="https://gaoboy.com/post/docker-network/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2016-03-01T14:18:33+08:00">
<meta property="article:modified_time" content="2016-03-01T14:18:33+08:00">
<meta itemprop=name content="Docker Network介绍">
<meta itemprop=description content="Docker 网络介绍"><meta itemprop=datePublished content="2016-03-01T14:18:33+08:00">
<meta itemprop=dateModified content="2016-03-01T14:18:33+08:00">
<meta itemprop=wordCount content="4470">
<meta itemprop=keywords content="docker,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Docker Network介绍">
<meta name=twitter:description content="Docker 网络介绍"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>猿资猿味</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>Home</li>
</a><a href=/post/>
<li class=mobile-menu-item>Archives</li>
</a><a href=/tags/>
<li class=mobile-menu-item>Tags</li>
</a><a href=/categories/>
<li class=mobile-menu-item>Categories</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>猿资猿味</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>Home</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>Archives</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>Tags</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>Categories</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<header class=post-header>
<h1 class=post-title>Docker Network介绍</h1>
<div class=post-meta>
<span class=post-time> 2016-03-01 </span>
<div class=post-category>
<a href=/categories/docker/> docker </a>
</div>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>文章目录</h2>
<div class="post-toc-content always-active">
<nav id=TableOfContents>
<ul>
<li><a href=#自定义容器命名>自定义容器命名</a></li>
<li><a href=#docker-容器互联>Docker 容器互联</a></li>
<li><a href=#docker-外部访问>Docker 外部访问</a>
<ul>
<li><a href=#映射所有接口地址>映射所有接口地址</a></li>
<li><a href=#映射到指定地址的指定端口>映射到指定地址的指定端口</a></li>
<li><a href=#映射到指定地址的任意端口>映射到指定地址的任意端口</a></li>
<li><a href=#查看映射端口配置>查看映射端口配置</a></li>
</ul>
</li>
<li><a href=#docker-网络命令>Docker 网络命令</a></li>
<li><a href=#docker-配置-dns>Docker 配置 DNS</a></li>
<li><a href=#docker-访问控制>Docker 访问控制</a>
<ul>
<li><a href=#容器访问外部网络>容器访问外部网络</a></li>
<li><a href=#容器之间访问>容器之间访问</a>
<ul>
<li><a href=#访问所有端口>访问所有端口</a></li>
<li><a href=#访问指定端口>访问指定端口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href=#docker-端口映射>Docker 端口映射</a>
<ul>
<li><a href=#容器访问外部实现>容器访问外部实现</a></li>
<li><a href=#外部访问容器实现>外部访问容器实现</a></li>
</ul>
</li>
<li><a href=#docker-配置网桥>Docker 配置网桥</a></li>
<li><a href=#docker-自定义网桥>Docker 自定义网桥</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<p>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。</p>
<p>该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。</p>
<h1 id=自定义容器命名>自定义容器命名</h1>
<p>连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。</p>
<p>虽然当创建容器的时候，系统默认会分配一个名字。自定义命名容器有 2 个好处：</p>
<ul>
<li>自定义的命名，比较好记，比如一个 web 应用容器我们可以给它起名叫 web</li>
<li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接 web 容器到 db 容器</li>
</ul>
<p>使用 <code>--name</code> 标记可以为容器自定义命名。</p>
<pre><code>$ sudo docker run -d -P --name web training/webapp python app.py
</code></pre><p>使用 <code>docker ps</code> 来验证设定的命名。</p>
<pre><code>$ sudo docker ps -l
CONTAINER ID  IMAGE                  COMMAND        CREATED       STATUS       PORTS                    NAMES
aed84ee21bde  training/webapp:latest python app.py  12 hours ago  Up 2 seconds 0.0.0.0:49154-&gt;5000/tcp  web
</code></pre><p>也可以使用 <code>docker inspect</code> 来查看容器的名字</p>
<pre><code>$ sudo docker inspect -f &quot;{{ .Name }}&quot; aed84ee21bde
/web
</code></pre><p>注意：容器的名称是唯一的。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个名称的时候，需要先用 <code>docker rm</code> 来删除之前创建的同名容器。</p>
<p>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意，<code>--rm</code> 和 <code>-d</code> 参数不能同时使用。</p>
<h1 id=docker-容器互联>Docker 容器互联</h1>
<p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互。</p>
<p>下面先创建一个新的数据库容器。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -d --name db training/postgres
</code></pre></div><p>删除之前创建的 web 容器</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker rm -f web
</code></pre></div><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -d -P --name web --link db:db training/webapp python app.py
</code></pre></div><p>此时，db 容器和 web 容器建立互联关系。</p>
<p><code>--link</code> 参数的格式为 <code>--link name:alias</code>，其中 <code>name</code> 是要链接的容器的名称，<code>alias</code> 是这个连接的别名。</p>
<p>使用 <code>docker ps</code> 来查看容器的连接</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker ps
CONTAINER ID  IMAGE                     COMMAND               CREATED             STATUS             PORTS                    NAMES
349169744e49  training/postgres:latest  su postgres -c <span style=color:#960050;background-color:#1e0010>&#39;</span>/usr  About a minute ago  Up About a minute  5432/tcp                 db, web/db
aed84ee21bde  training/webapp:latest    python app.py         <span style=color:#ae81ff>16</span> hours ago        Up <span style=color:#ae81ff>2</span> minutes       0.0.0.0:49154-&gt;5000/tcp  web
</code></pre></div><p>可以看到自定义命名的容器，db 和 web，db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。</p>
<p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 <code>-p</code> 和 <code>-P</code> 标记，从而避免了暴露数据库端口到外部网络上。</p>
<p>Docker 通过 2 种方式为容器公开连接信息：</p>
<ul>
<li>环境变量</li>
<li>更新 <code>/etc/hosts</code> 文件</li>
</ul>
<p>使用 <code>env</code> 命令来查看 web 容器的环境变量</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run --rm --name web2 --link db:db training/webapp env
. . .
DB_NAME<span style=color:#f92672>=</span>/web2/db
DB_PORT<span style=color:#f92672>=</span>tcp://172.17.0.5:5432
DB_PORT_5000_TCP<span style=color:#f92672>=</span>tcp://172.17.0.5:5432
DB_PORT_5000_TCP_PROTO<span style=color:#f92672>=</span>tcp
DB_PORT_5000_TCP_PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>5432</span>
DB_PORT_5000_TCP_ADDR<span style=color:#f92672>=</span>172.17.0.5
. . .
</code></pre></div><p>其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。</p>
<p>除了环境变量，Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 hosts 文件</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -t -i --rm --link db:db training/webapp /bin/bash
root@aed84ee21bde:/opt/webapp# cat /etc/hosts
172.17.0.7  aed84ee21bde
. . .
172.17.0.5  db
</code></pre></div><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器的 ip 和主机名。 可以在 web 容器中安装 ping 命令来测试跟 db 容器的连通。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>root@aed84ee21bde:/opt/webapp# apt-get install -yqq inetutils-ping
root@aed84ee21bde:/opt/webapp# ping db
PING db <span style=color:#f92672>(</span>172.17.0.5<span style=color:#f92672>)</span>: <span style=color:#ae81ff>48</span> data bytes
<span style=color:#ae81ff>56</span> bytes from 172.17.0.5: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.267 ms
<span style=color:#ae81ff>56</span> bytes from 172.17.0.5: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.250 ms
<span style=color:#ae81ff>56</span> bytes from 172.17.0.5: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.256 ms
</code></pre></div><p>用 ping 来测试 db 容器，它会解析成 <code>172.17.0.5</code>。 * 注意：官方的 ubuntu 镜像默认没有安装 ping，需要自行安装。</p>
<p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p>
<h1 id=docker-外部访问>Docker 外部访问</h1>
<p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 -P 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker ps</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -d -P training/webapp python app.py
$ sudo docker ps -l
CONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES
bc533791f3f5  training/webapp:latest  python app.py <span style=color:#ae81ff>5</span> seconds ago  Up <span style=color:#ae81ff>2</span> seconds  0.0.0.0:49155-&gt;5000/tcp  nostalgic_morse
</code></pre></div><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker logs -f nostalgic_morse
* Running on http://0.0.0.0:5000/
10.0.2.2 - - <span style=color:#f92672>[</span>23/May/2014 20:16:31<span style=color:#f92672>]</span> <span style=color:#e6db74>&#34;GET / HTTP/1.1&#34;</span> <span style=color:#ae81ff>200</span> -
10.0.2.2 - - <span style=color:#f92672>[</span>23/May/2014 20:16:31<span style=color:#f92672>]</span> <span style=color:#e6db74>&#34;GET /favicon.ico HTTP/1.1&#34;</span> <span style=color:#ae81ff>404</span> -
</code></pre></div><p>-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h2 id=映射所有接口地址>映射所有接口地址</h2>
<p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -d -p 5000:5000 training/webapp python app.py
</code></pre></div><p>此时默认会绑定本地所有接口上的所有地址。</p>
<h2 id=映射到指定地址的指定端口>映射到指定地址的指定端口</h2>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
</code></pre></div><h2 id=映射到指定地址的任意端口>映射到指定地址的任意端口</h2>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -d -p 127.0.0.1::5000 training/webapp python app.py
</code></pre></div><p>还可以使用 udp 标记来指定 udp 端口</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
</code></pre></div><h2 id=查看映射端口配置>查看映射端口配置</h2>
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker port nostalgic_morse <span style=color:#ae81ff>5000</span>
127.0.0.1:49155.
</code></pre></div><p>注意：</p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li>
<li>-p 标记可以多次使用来绑定多个端口</li>
</ul>
<p>例如</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -d -p 5000:5000  -p 3000:80 training/webapp python app.py
</code></pre></div><h1 id=docker-网络命令>Docker 网络命令</h1>
<p>下面是一个跟 Docker 网络相关的命令列表。</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li><code>-b BRIDGE or --bridge=BRIDGE</code> &ndash; 指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code> &ndash; 定制 docker0 的掩码</li>
<li><code>-H SOCKET... or --host=SOCKET...</code> &ndash;Docker 服务端接收命令的通道</li>
<li><code>--icc=true|false</code> &ndash; 是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> &ndash; 请看下文容器之间的通信</li>
<li><code>--iptables=true|false</code> &ndash; 禁止 Docker 添加 iptables 规则</li>
<li><code>--mtu=BYTES</code> &ndash; 容器网络中的 MTU</li>
</ul>
<p>下面 2 个命令选项既可以在启动服务时指定，也可以 Docker 容器启动（<code>docker run</code>）时候指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> &ndash; 使用指定的 DNS 服务器</li>
<li><code>--dns-search=DOMAIN...</code> &ndash; 指定 DNS 搜索域</li>
</ul>
<p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li><code>-h HOSTNAME or --hostname=HOSTNAME</code> &ndash; 配置容器主机名</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> &ndash; 添加到另一个容器的连接</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> &ndash; 配置容器的桥接模式</li>
<li><code>-p SPEC or --publish=SPEC</code> &ndash; 映射容器端口到宿主主机</li>
<li><code>-P or --publish-all=true|false</code> &ndash; 映射容器所有端口到宿主主机</li>
</ul>
<h1 id=docker-配置-dns>Docker 配置 DNS</h1>
<p>Docker 没有为每个容器专门定制镜像，那么怎么自定义配置容器的主机名和 DNS 配置呢？ 秘诀就是它利用虚拟文件来挂载到来容器的 3 个相关配置文件。</p>
<p>在容器中使用 mount 命令可以看到挂载信息：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ mount
...
/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ...
/dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...
tmpfs on /etc/resolv.conf type tmpfs ...
...
</code></pre></div><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 dns 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p>
<p>如果用户想要手动指定容器的配置，可以利用下面的选项。</p>
<p><code>-h HOSTNAME or --hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker ps</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p>
<p><code>--link=CONTAINER_NAME:ALIAS</code> 选项会在创建容器的时候，添加一个其他容器的主机名到 <code>/etc/hosts</code> 文件中，让新容器的进程可以使用主机名 ALIAS 就可以连接它。</p>
<p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p>
<p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。 注意：如果没有上述最后 2 个选项，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p>
<h1 id=docker-访问控制>Docker 访问控制</h1>
<p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h2 id=容器访问外部网络>容器访问外部网络</h2>
<p>容器要想访问外部网络，需要本地系统的转发支持。在 Linux 系统中，检查转发是否打开。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$sysctl net.ipv4.ip_forward
net.ipv4.ip_forward <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</code></pre></div><p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$sysctl -w net.ipv4.ip_forward<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</code></pre></div><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p>
<h2 id=容器之间访问>容器之间访问</h2>
<p>容器之间相互访问，需要两方面的支持。</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li>
<li>本地系统的防火墙软件 &ndash; <code>iptables</code> 是否允许通过。</li>
</ul>
<h3 id=访问所有端口>访问所有端口</h3>
<p>当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置 <code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/default/docker</code> 文件中配置 <code>DOCKER_OPTS=--icc=false</code> 来禁止它。</p>
<h3 id=访问指定端口>访问指定端口</h3>
<p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p>
<p>此时，系统中的 <code>iptables</code> 规则可能是类似</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo iptables -nL
...
Chain FORWARD <span style=color:#f92672>(</span>policy ACCEPT<span style=color:#f92672>)</span>
target     prot opt source               destination
DROP       all  --  0.0.0.0/0            0.0.0.0/0
...
</code></pre></div><p>之后，启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 行）。</p>
<p>当添加了 <code>--link=CONTAINER_NAME:ALIAS</code> 选项后，添加了 <code>iptables</code> 规则。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo iptables -nL
...
Chain FORWARD <span style=color:#f92672>(</span>policy ACCEPT<span style=color:#f92672>)</span>
target     prot opt source               destination
ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80
ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80
DROP       all  --  0.0.0.0/0            0.0.0.0/0
</code></pre></div><p>注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 <code>--name</code> 参数指定的名字。主机名则不会被识别。</p>
<h1 id=docker-端口映射>Docker 端口映射</h1>
<p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h2 id=容器访问外部实现>容器访问外部实现</h2>
<p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo iptables -t nat -nL
...
Chain POSTROUTING <span style=color:#f92672>(</span>policy ACCEPT<span style=color:#f92672>)</span>
target     prot opt source               destination
MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16
...
</code></pre></div><p>其中，上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h2 id=外部访问容器实现>外部访问容器实现</h2>
<p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p>
<p>不管用哪种办法，其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p>
<p>使用 <code>-P</code> 时：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ iptables -t nat -nL
...
Chain DOCKER <span style=color:#f92672>(</span><span style=color:#ae81ff>2</span> references<span style=color:#f92672>)</span>
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80
</code></pre></div><p>使用 <code>-p 80:80</code> 时：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ iptables -t nat -nL
Chain DOCKER <span style=color:#f92672>(</span><span style=color:#ae81ff>2</span> references<span style=color:#f92672>)</span>
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80
</code></pre></div><p>注意：</p>
<ul>
<li>这里的规则映射了 0.0.0.0，意味着将接受主机来自所有接口的流量。用户可以通过 <code>-p IP:host_port:container_port</code> 或 <code>-p IP::port</code> 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</li>
<li>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/default/docker</code> 中指定 <code>DOCKER_OPTS="--ip=IP_ADDRESS"</code>，之后重启 Docker 服务即可生效。</li>
</ul>
<h1 id=docker-配置网桥>Docker 配置网桥</h1>
<p>Docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 <code>docker0</code> 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<ul>
<li><code>--bip=CIDR</code> &ndash; IP 地址加掩码格式，例如 192.168.1.5/24</li>
<li><code>--mtu=BYTES</code> &ndash; 覆盖默认的 Docker mtu 配置</li>
</ul>
<p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。 由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.3a1d7362b4ee       no              veth65f9vethdda6
</code></pre></div><blockquote>
<p>注：<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p>
</blockquote>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo docker run -i -t --rm base /bin/bash
$ ip addr show eth0
24: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu <span style=color:#ae81ff>1500</span> qdisc pfifo_fast state UP group default qlen <span style=color:#ae81ff>1000</span>
    link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.3/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::306f:e0ff:fe35:5791/64 scope link
       valid_lft forever preferred_lft forever
$ ip route
default via 172.17.42.1 dev eth0
172.17.0.0/16 dev eth0  proto kernel  scope link  src 172.17.0.3
$ exit
</code></pre></div><h1 id=docker-自定义网桥>Docker 自定义网桥</h1>
<p>除了默认的 <code>docker0</code> 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo service docker stop
$ sudo ip link set dev docker0 down
$ sudo brctl delbr docker0
</code></pre></div><p>然后创建一个网桥 <code>bridge0</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo brctl addbr bridge0
$ sudo ip addr add 192.168.5.1/24 dev bridge0
$ sudo ip link set dev bridge0 up
</code></pre></div><p>查看确认网桥创建并启动。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip addr show bridge0
4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu <span style=color:#ae81ff>1500</span> qdisc noop state UP group default
    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff
    inet 192.168.5.1/24 scope global bridge0
       valid_lft forever preferred_lft forever
</code></pre></div><p>配置 Docker 服务，默认桥接到创建的网桥上。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ echo <span style=color:#e6db74>&#39;DOCKER_OPTS=&#34;-b=bridge0&#34;&#39;</span> &gt;&gt; /etc/default/docker
$ sudo service docker start
</code></pre></div><p>启动 Docker 服务。 新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p>
<p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=/tags/docker/>docker</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/docker-safety/>
<i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Docker 安全介绍</span>
<span class="prev-text nav-mobile">上一篇</span>
</a>
<a class=next href=/post/docker-volume/>
<span class="next-text nav-default">Docker 数据卷介绍</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i>
</a>
</nav>
</footer>
</article>
</div>
<div id=vcomments></div>
<script src=//cdn1.lncld.net/static/js/3.0.4/av-min.js></script>
<script src=//unpkg.com/valine/dist/Valine.min.js></script>
<script type=text/javascript>new Valine({el:'#vcomments',appId:'fXqv8lFikU96F2xUDOBW4T9X-MdYXbMMI',appKey:'AUbjromOz15du9OJSTY6Q8HM',notify:!1,verify:!1,avatar:'robohash',placeholder:'本站支持评论邮件提醒功能，在上方邮箱输入框留下邮箱，可以收到回复通知哦！（支持markdown语法）',visitor:!1})</script>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=mailto:gao.bo168@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/forgottener class="iconfont icon-github" title=github></a>
<a href=https://space.bilibili.com/1714562 class="iconfont icon-bilibili" title=bilibili></a>
<a href=https://gaoboy.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=power-by>
由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span>
<span class=division>|</span>
<span class=theme-info>
主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span>
<span class=copyright-year>
&copy;
2013 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span><a rel="license noopener" href=https://beian.miit.gov.cn/ target=_blank>浙ICP备14043338号-2</a>~<a rel="license noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010802003111" target=_blank>浙公网安备 33010802003111号</a></span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
<script src=/js/blank.js></script>
</body>
</html>